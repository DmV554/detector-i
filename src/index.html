<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Detector de Placas Vehiculares (Cámara)</title>
    <style>
        /* --- Estilos CSS (sin cambios) --- */
        body {
            font-family: Arial, sans-serif; max-width: 900px; margin: 0 auto;
            padding: 20px; background-color: #f9f9f9;
        }
        h1 { color: #333; text-align: center; margin-bottom: 30px; }
        .container {
            display: flex; flex-direction: column; gap: 20px; background-color: #fff;
            padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .options {
            display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px;
            align-items: center; border-bottom: 1px solid #eee; padding-bottom: 20px;
        }
        .video-container {
            border: 1px solid #ddd; padding: 15px; border-radius: 5px; background-color: #fdfdfd;
            min-height: 300px; display: flex; flex-direction: column; align-items: center;
            position: relative; /* Para superponer el canvas */
        }
        .video-container h3 { margin-top: 0; margin-bottom: 10px; color: #555; text-align: center; }

        #videoFeed {
            display: block; /* Video visible */
            width: 100%;
            max-width: 640px; /* O el tamaño que desees */
            height: auto;
            border: 1px solid #888;
        }
        #processedCanvas { /* Canvas para DIBUJAR bounding boxes */
            position: absolute;
            top: 0; /* Ajustar según el padding del video-container y el h3 */
            left: 0; /* Ajustar si hay márgenes */
            width: 100%; /* Se ajustará con JS */
            height: 100%; /* Se ajustará con JS */
            pointer-events: none; /* Para que no interfiera con el video si está encima */
        }
        .results {
            margin-top: 20px; padding: 15px; background-color: #f0f0f0; border-radius: 5px;
            white-space: pre-wrap; font-family: 'Courier New', Courier, monospace;
            border: 1px solid #e0e0e0; max-height: 200px; overflow-y: auto; min-height: 50px;
        }
        .results:empty::before { content: "Los resultados aparecerán aquí..."; color: #888; font-style: italic;}
        .loader {
            border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%;
            width: 30px; height: 30px; animation: spin 1s linear infinite;
            margin: 0 10px; display: none;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .button {
            padding: 10px 20px; background-color: #4CAF50; color: white; border: none;
            border-radius: 4px; cursor: pointer; font-size: 16px;
            transition: background-color 0.2s ease; height: 40px; box-sizing: border-box;
        }
        .button:hover:not(:disabled) { background-color: #45a049; }
        .button:disabled { background-color: #cccccc; cursor: not-allowed; }
        .button.stop { background-color: #f44336; }
        .button.stop:hover:not(:disabled) { background-color: #d32f2f; }
        select {
            padding: 0 10px; font-size: 16px; border-radius: 4px;
            border: 1px solid #ddd; height: 40px; box-sizing: border-box; max-width: 250px;
        }
        label { margin-right: 5px; font-weight: bold; white-space: nowrap; }
        .status {
            margin-top: 10px; text-align: center; color: #666;
            min-height: 20px; font-style: italic;
        }
        .coep-info {
            padding:10px; margin-bottom:15px; background-color: #fff3cd; border: 1px solid #ffeeba;
            color: #856404; border-radius: 4px; text-align: center; font-size: 0.9em;
        }
        .coep-info code { background-color: #e9ecef; padding: 2px 4px; border-radius: 3px; }
        .coep-info a { color: #007bff; }
    </style>
</head>
<body>

    <h1>Detector de Placas Vehiculares (Cámara)</h1>

    <div class="coep-info">
        <strong>Nota Importante:</strong> Para un rendimiento óptimo (multithreading con Web Workers y SharedArrayBuffer para ONNX Runtime), esta página debe servirse con cabeceras COOP y COEP.
        <br><code>Cross-Origin-Opener-Policy: same-origin</code>
        <br><code>Cross-Origin-Embedder-Policy: require-corp</code> (o <code>credentialless</code> para mayor compatibilidad si los scripts de terceros lo permiten)
        <br>Usar "Live Server" en VSCode con un archivo `server.js` (o similar) que añada estas cabeceras es una forma de lograrlo.
    </div>

    <div class="container">
        <div class="options">
            <label for="modelSelect">Detector:</label>
            <select id="modelSelect">
                <option value="yolo-v9-t-256-license-plates-end2end">YOLOv9-t-256 (rápido)</option>
                <option value="yolo-v9-t-384-license-plates-end2end">YOLOv9-t-384</option>
                <option value="yolo-v9-t-512-license-plates-end2end" selected>YOLOv9-t-512 (balanceado)</option>
                <option value="yolo-v9-s-608-license-plates-end2end">YOLOv9-s-608 (preciso)</option>
            </select>
            <button id="cameraButton" class="button">Iniciar Cámara</button>
            <div id="loader" class="loader"></div>
        </div>

        <div id="status" class="status">Selecciona un modelo y presiona "Iniciar Cámara".</div>

        <div class="video-container">
            <h3>Video</h3> <video id="videoFeed" playsinline autoplay muted></video> <canvas id="processedCanvas"></canvas> </div>

        <div class="results" id="resultsArea"></div>
    </div>

    <script type="module">
        // No se importa ALPR aquí, se usa en el worker.

        // Configuración de ONNX Runtime Web para el HILO PRINCIPAL (si se usara aquí)
        // Esto es menos relevante ahora que la inferencia está en el worker.
        /*
        try {
            if (typeof ort !== 'undefined') { // Solo si ort está cargado en el hilo principal
                if (self.crossOriginIsolated) {
                    ort.env.wasm.numThreads = Math.max(1, Math.min(navigator.hardwareConcurrency || 4, 4));
                    console.info(`ONNX Runtime (Main Thread): Usando ${ort.env.wasm.numThreads} hilos.`);
                } else {
                    ort.env.wasm.numThreads = 1;
                    console.warn('ONNX Runtime (Main Thread): crossOriginIsolated es false. Usando 1 hilo.');
                }
                ort.env.wasm.simd = true;
            }
        } catch (e) {
            console.error("Error configurando ONNX Runtime en hilo principal:", e);
        }
        */

        document.addEventListener('DOMContentLoaded', () => {
            const modelSelect = document.getElementById('modelSelect');
            const cameraButton = document.getElementById('cameraButton');
            const loader = document.getElementById('loader');
            const statusDiv = document.getElementById('status');
            const videoElement = document.getElementById('videoFeed');
            const processedCanvas = document.getElementById('processedCanvas'); // Canvas para dibujar
            const resultsArea = document.getElementById('resultsArea');
            const canvasCtx = processedCanvas.getContext('2d');

            let alprWorker = null;
            let isWorkerInitialized = false;
            const ocrModelName = "global-plates-mobile-vit-v2-model"; // Modelo OCR fijo
            let currentDetectorModelName = modelSelect.value;
            let isCameraRunning = false;
            let videoStream = null;
            let animationFrameId = null;
            let frameCounter = 0; // Para rastrear frames enviados al worker

            const TARGET_FPS_PROCESSING = 3; // FPS deseado para el procesamiento en el worker
            let lastProcessTime = 0;
            let processingFrameInWorker = false; // Flag para saber si el worker está ocupado

            function updateStatus(message, isError = false) {
                statusDiv.textContent = message;
                statusDiv.style.color = isError ? 'red' : '#666';
                if (isError) console.error(message); else console.info(message);
            }

            function showLoader(show) {
                loader.style.display = show ? 'inline-block' : 'none';
                cameraButton.disabled = show;
            }

            async function initializeAlprWorker() {
                showLoader(true);
                currentDetectorModelName = modelSelect.value;
                updateStatus(`Inicializando ALPR Worker con: ${currentDetectorModelName}...`);

                if (alprWorker) {
                    console.log("Terminando worker ALPR anterior...");
                    alprWorker.terminate();
                    alprWorker = null;
                }
                isWorkerInitialized = false;
                // La ruta a alpr-worker.js debe ser correcta desde la raíz del servidor.
                    alprWorker = new Worker('./alpr_worker.js', { type: 'module' });

                alprWorker.onmessage = function (e) {
                    const { type, success, error, results, frameId } = e.data;

                    if (type === 'initComplete') {
                        showLoader(false);
                        if (success) {
                            isWorkerInitialized = true;
                            updateStatus(`ALPR Worker inicializado (${currentDetectorModelName}).`);
                            if (isCameraRunning && !animationFrameId) { // Si la cámara se inició mientras el worker cargaba
                                lastProcessTime = performance.now();
                                animationFrameId = requestAnimationFrame(videoProcessingLoop);
                            }
                        } else {
                            updateStatus(`Error al inicializar ALPR Worker: ${error || 'Desconocido'}`, true);
                            alprWorker = null;
                        }
                    } else if (type === 'frameProcessed') {
                        processingFrameInWorker = false; // Worker está libre
                        // console.log(`Hilo Principal: Frame ${frameId} procesado.`);
                        if (error) {
                            console.error(`Error del Worker (frame ${frameId}):`, error);
                        } else if (results) {
                            // Dibujar resultados en el canvas superpuesto
                            drawAlprResults(results, processedCanvas, canvasCtx, videoElement);

                            if (results.length > 0) {
                                let resultsTextContent = `Detecciones: ${results.length}\n\n`;
                                results.forEach((item, index) => {
                                    const det = item.detection;
                                    const ocr = item.ocr;
                                    const detConf = det && typeof det.confidence === 'number' ? (det.confidence * 100).toFixed(1) : "N/A";
                                    const ocrText = ocr && ocr.text ? ocr.text : "N/A";
                                    const ocrConf = ocr && typeof ocr.confidence === 'number' ? (ocr.confidence * 100).toFixed(1) : "N/A";
                                    resultsTextContent += `Placa ${index + 1}: ${ocrText} (OCR:${ocrConf}%) (Det:${detConf}%)\n`;
                                });
                                resultsArea.textContent = resultsTextContent.trim();
                            } else {
                                // resultsArea.textContent = "No se encontraron placas.";
                                // No limpiar las cajas viejas explícitamente aquí,
                                // drawAlprResults se encarga de limpiar y redibujar.
                                // Si no hay results, drawAlprResults simplemente limpia.
                            }
                        }
                    } else if (type === 'initError') { // Manejar errores de inicialización del worker
                        showLoader(false);
                        updateStatus(`Error crítico inicializando Worker: ${error}`, true);
                        alprWorker = null;
                    }
                };

                alprWorker.onerror = function(err) {
                    console.error("Error en ALPR Worker:", err.message, err);
                    updateStatus(`Error fatal en ALPR Worker: ${err.message}`, true);
                    showLoader(false);
                    isWorkerInitialized = false;
                    if (alprWorker) alprWorker.terminate();
                    alprWorker = null;
                };

                console.log("Hilo Principal: Enviando mensaje 'init' al worker...");
                alprWorker.postMessage({
                    type: 'init',
                    payload: {
                        detectorModel: currentDetectorModelName,
                        ocrModel: ocrModelName
                    }
                });
            }

            function drawAlprResults(alprResults, canvas, ctx, videoSourceElement) {
                // Sincronizar tamaño del canvas con el del video actual
                if (canvas.width !== videoSourceElement.videoWidth || canvas.height !== videoSourceElement.videoHeight) {
                    canvas.width = videoSourceElement.videoWidth;
                    canvas.height = videoSourceElement.videoHeight;
                }
                // Ajustar CSS para que el canvas se superponga correctamente
                // Esto asume que videoElement es el referente para el tamaño del canvas.
                const videoRect = videoSourceElement.getBoundingClientRect();
                canvas.style.position = 'absolute';
                canvas.style.left = videoSourceElement.offsetLeft + 'px';
                canvas.style.top = videoSourceElement.offsetTop + 'px';
                canvas.width = videoRect.width; // Usar dimensiones renderizadas
                canvas.height = videoRect.height;


                ctx.clearRect(0, 0, canvas.width, canvas.height); // Limpiar canvas antes de dibujar

                if (!alprResults || alprResults.length === 0) return;

                // Escalas para convertir coordenadas del frame original (videoWidth/videoHeight)
                // al tamaño del canvas de dibujo (que ahora coincide con el video renderizado).
                const scaleX = canvas.width / videoSourceElement.videoWidth;
                const scaleY = canvas.height / videoSourceElement.videoHeight;

                alprResults.forEach(item => {
                    const { detection, ocr } = item;
                    if (!detection || !detection.boundingBox) return;

                    const bb = detection.boundingBox;
                    const x1 = bb.x1 * scaleX;
                    const y1 = bb.y1 * scaleY;
                    const width = (bb.x2 - bb.x1) * scaleX;
                    const height = (bb.y2 - bb.y1) * scaleY;

                    ctx.strokeStyle = 'lime';
                    ctx.lineWidth = Math.max(1, Math.min(2, canvas.width / 320)); // Grosor adaptativo
                    ctx.strokeRect(x1, y1, width, height);

                    const detConf = typeof detection.confidence === 'number' ? (detection.confidence * 100).toFixed(0) : "";
                    const ocrTextLabel = ocr && ocr.text ? ocr.text : "";
                    const ocrConfLabel = ocr && typeof ocr.confidence === 'number' ? (ocr.confidence * 100).toFixed(0) : "";
                    const label = `${ocrTextLabel} (D:${detConf}% O:${ocrConfLabel}%)`;

                    const fontHeight = Math.max(10, Math.min(14, Math.round(canvas.width / 40))); // Tamaño de fuente adaptativo
                    ctx.font = `bold ${fontHeight}px Arial`;
                    ctx.textBaseline = 'bottom';
                    const textMetrics = ctx.measureText(label);
                    const textWidth = textMetrics.width;

                    ctx.fillStyle = 'rgba(0, 255, 0, 0.75)'; // Fondo semi-transparente
                    ctx.fillRect(x1, y1 - (fontHeight + 4), textWidth + 4, fontHeight + 4);
                    ctx.fillStyle = 'black';
                    ctx.fillText(label, x1 + 2, y1 - 2);
                });
            }

            async function startVideoStream() {
                if (isCameraRunning) return;
                if (!alprWorker || !isWorkerInitialized) {
                    updateStatus("ALPR Worker no inicializado. Por favor espera o reintenta.", true);
                    await initializeAlprWorker(); // Intentar inicializar si no lo está
                    if(!isWorkerInitialized) { // Si falló de nuevo
                        showLoader(false);
                        return;
                    }
                }

                updateStatus("Iniciando cámara...");
                showLoader(true);
                try {
                    const constraints = {
                        video: {
                            // width: { ideal: 640 }, height: { ideal: 480 }, // Puedes especificar tamaños ideales
                            facingMode: "environment"
                        },
                        audio: false
                    };
                    videoStream = await navigator.mediaDevices.getUserMedia(constraints);
                    videoElement.srcObject = videoStream;
                    // videoElement.play(); // Autoplay está activado

                    videoElement.onloadedmetadata = () => { // Se dispara una vez que las dimensiones del video son conocidas
                        // Sincronizar tamaño del canvas de dibujo con el video
                        processedCanvas.width = videoElement.videoWidth;
                        processedCanvas.height = videoElement.videoHeight;
                        // Ajustar CSS del canvas para superposición correcta
                        const videoRect = videoElement.getBoundingClientRect();
                        processedCanvas.style.position = 'absolute';
                        processedCanvas.style.left = videoElement.offsetLeft + 'px';
                        processedCanvas.style.top = videoElement.offsetTop + 'px';
                        processedCanvas.style.width = videoRect.width + 'px';
                        processedCanvas.style.height = videoRect.height + 'px';


                        isCameraRunning = true;
                        cameraButton.textContent = 'Detener Cámara';
                        cameraButton.classList.add('stop');
                        showLoader(false);
                        updateStatus("Cámara iniciada. Procesando frames...");

                        lastProcessTime = performance.now();
                        processingFrameInWorker = false;
                        if (animationFrameId) cancelAnimationFrame(animationFrameId);
                        animationFrameId = requestAnimationFrame(videoProcessingLoop);
                    };

                } catch (error) {
                    updateStatus(`Error al acceder a la cámara: ${error.message}`, true);
                    isCameraRunning = false;
                    showLoader(false);
                }
            }

            function stopVideoStream() {
                if (!isCameraRunning) return;
                updateStatus("Deteniendo cámara...");
                if (videoStream) {
                    videoStream.getTracks().forEach(track => track.stop());
                }
                videoElement.srcObject = null;
                isCameraRunning = false;
                cameraButton.textContent = 'Iniciar Cámara';
                cameraButton.classList.remove('stop');
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                canvasCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
                resultsArea.textContent = '';
                updateStatus("Cámara detenida.");
                showLoader(false);
                processingFrameInWorker = false;
            }

            // Bucle de renderizado del video y envío de frames al worker
            function videoProcessingLoop(currentTime) {
                if (!isCameraRunning) {
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                    return;
                }

                // Dibujar el video en el elemento <video> es automático por el navegador.
                // El canvas 'processedCanvas' solo se usa para dibujar las bounding boxes.

                const deltaTime = currentTime - lastProcessTime;
                const interval = 1000 / TARGET_FPS_PROCESSING;

                if (deltaTime >= interval && !processingFrameInWorker && isWorkerInitialized && videoElement.readyState >= videoElement.HAVE_METADATA && videoElement.videoWidth > 0) {
                    lastProcessTime = currentTime - (deltaTime % interval);
                    processingFrameInWorker = true;
                    frameCounter++;

                    // Capturar ImageData del videoElement para enviar al worker
                    // Es mejor crear un canvas temporal para esto para no depender del canvas de dibujo
                    const tempCaptureCanvas = document.createElement('canvas');
                    tempCaptureCanvas.width = videoElement.videoWidth; // Usar dimensiones reales del video
                    tempCaptureCanvas.height = videoElement.videoHeight;
                    const tempCtx = tempCaptureCanvas.getContext('2d', { willReadFrequently: true });
                    tempCtx.drawImage(videoElement, 0, 0, tempCaptureCanvas.width, tempCaptureCanvas.height);
                    const imageData = tempCtx.getImageData(0, 0, tempCaptureCanvas.width, tempCaptureCanvas.height);

                    // console.log(`Hilo Principal: Enviando frame ${frameCounter} al worker.`);
                    alprWorker.postMessage({
                        type: 'processFrame',
                        payload: imageData,
                        frameId: frameCounter
                    }, [imageData.data.buffer]); // Transferir el buffer para mejor rendimiento
                }
                animationFrameId = requestAnimationFrame(videoProcessingLoop);
            }

            // --- Event Listeners ---
            modelSelect.addEventListener('change', async () => {
                currentDetectorModelName = modelSelect.value; // Actualizar variable global
                updateStatus(`Detector cambiado a: ${currentDetectorModelName}. Reinicializando ALPR Worker...`);
                if (isCameraRunning) {
                    stopVideoStream();
                }
                await initializeAlprWorker(); // Reinicia el worker con el nuevo modelo
                // No es necesario informar al usuario que reinicie la cámara,
                // si estaba activa, ya se detuvo. Puede volver a iniciarla.
            });

            cameraButton.addEventListener('click', () => {
                // La verificación de OpenCV ya no es necesaria aquí, se hace en el worker.
                if (isCameraRunning) {
                    stopVideoStream();
                } else {
                    if (!alprWorker || !isWorkerInitialized) {
                       initializeAlprWorker().then(() => {
                           if (isWorkerInitialized) startVideoStream();
                       }).catch(err => {
                            console.error("Fallo en secuencia de inicialización/arranque de cámara", err);
                       });
                    } else {
                        startVideoStream();
                    }
                }
            });

            // --- Inicialización al Cargar la Página ---
            updateStatus('Aplicación inicializada. Esperando interacción del usuario.', false);
            cameraButton.disabled = false; // Habilitar botón de cámara
            // Opcional: Pre-inicializar el worker al cargar la página
            // initializeAlprWorker();
        });
    </script>

</body>
</html>