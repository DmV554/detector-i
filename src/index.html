<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Detector de Placas Vehiculares (Cámara)</title>
    <style>
        /* --- Estilos CSS (sin cambios significativos, puedes mantener los tuyos) --- */
        body {
            font-family: Arial, sans-serif; max-width: 900px; margin: 0 auto;
            padding: 20px; background-color: #f9f9f9;
        }
        h1 { color: #333; text-align: center; margin-bottom: 30px; }
        .container {
            display: flex; flex-direction: column; gap: 20px; background-color: #fff;
            padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .options {
            display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px;
            align-items: center; border-bottom: 1px solid #eee; padding-bottom: 20px;
        }
        .video-container {
            border: 1px solid #ddd; padding: 15px; border-radius: 5px; background-color: #fdfdfd;
            min-height: 300px; display: flex; flex-direction: column; align-items: center;
            position: relative; /* Para superponer el canvas */
        }
        .video-container h3 { margin-top: 0; margin-bottom: 10px; color: #555; text-align: center; }

        #videoFeed {
            display: block;
            width: 100%;
            max-width: 640px;
            height: auto;
            border: 1px solid #888;
        }
        #processedCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .results {
            margin-top: 20px; padding: 15px; background-color: #f0f0f0; border-radius: 5px;
            white-space: pre-wrap; font-family: 'Courier New', Courier, monospace;
            border: 1px solid #e0e0e0; max-height: 200px; overflow-y: auto; min-height: 50px;
        }
        .results:empty::before { content: "Los resultados aparecerán aquí..."; color: #888; font-style: italic;}
        .loader {
            border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%;
            width: 30px; height: 30px; animation: spin 1s linear infinite;
            margin: 0 10px; display: none;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .button {
            padding: 10px 20px; background-color: #4CAF50; color: white; border: none;
            border-radius: 4px; cursor: pointer; font-size: 16px;
            transition: background-color 0.2s ease; height: 40px; box-sizing: border-box;
        }
        .button:hover:not(:disabled) { background-color: #45a049; }
        .button:disabled { background-color: #cccccc; cursor: not-allowed; }
        .button.stop { background-color: #f44336; }
        .button.stop:hover:not(:disabled) { background-color: #d32f2f; }
        select, input[type="number"] { /* Añadido input */
            padding: 0 10px; font-size: 16px; border-radius: 4px;
            border: 1px solid #ddd; height: 40px; box-sizing: border-box; max-width: 250px;
        }
        label { margin-right: 5px; font-weight: bold; white-space: nowrap; }
        .status {
            margin-top: 10px; text-align: center; color: #666;
            min-height: 20px; font-style: italic;
        }
        .coep-info {
            padding:10px; margin-bottom:15px; background-color: #fff3cd; border: 1px solid #ffeeba;
            color: #856404; border-radius: 4px; text-align: center; font-size: 0.9em;
        }
        .coep-info code { background-color: #e9ecef; padding: 2px 4px; border-radius: 3px; }
    </style>
</head>
<body>

    <h1>Detector de Placas Vehiculares (Cámara)</h1>

    <div class="coep-info">
        <strong>Nota Importante:</strong> Se requieren cabeceras COOP y COEP para SharedArrayBuffer.
        <br><code>Cross-Origin-Opener-Policy: same-origin</code>
        <br><code>Cross-Origin-Embedder-Policy: require-corp</code>
    </div>

    <div class="container">
        <div class="options">
            <label for="detectorModelSelect">Detector:</label>
            <select id="detectorModelSelect">
                </select>
            <label for="confThreshInput">Confianza:</label>
            <input type="number" id="confThreshInput" value="0.25" step="0.05" min="0.1" max="0.95" style="width: 70px;">

            <button id="cameraButton" class="button">Iniciar Cámara</button>
            <div id="loader" class="loader"></div>
        </div>

        <div id="status" class="status">Cargando configuración...</div>

        <div class="video-container">
            <h3>Video</h3>
            <video id="videoFeed" playsinline autoplay muted></video>
            <canvas id="processedCanvas"></canvas>
        </div>

        <div class="results" id="resultsArea"></div>
    </div>

    <script type="module">
        const modelSelect = document.getElementById('detectorModelSelect'); // Renombrado de 'modelSelect' a 'detectorModelSelect' en el HTML
        // const ocrModelSelect = document.getElementById('ocrModelSelect'); // Si lo añades
        const confThreshInput = document.getElementById('confThreshInput');
        const cameraButton = document.getElementById('cameraButton');
        const loader = document.getElementById('loader');
        const statusDiv = document.getElementById('status');
        const videoElement = document.getElementById('videoFeed');
        const processedCanvas = document.getElementById('processedCanvas');
        const resultsArea = document.getElementById('resultsArea');
        const canvasCtx = processedCanvas.getContext('2d');

        let alprWorker = null;
        let isWorkerInitialized = false;
        let isCameraRunning = false;
        let videoStream = null;
        let animationFrameId = null;
        let frameCounter = 0;
        let processingFrameInWorker = false;
        const TARGET_FPS_PROCESSING = 5; // Ajusta según necesites
        let lastProcessTime = 0;
        let appConfig = null; // Para almacenar la configuración cargada

        function updateStatus(message, isError = false) {
            statusDiv.textContent = message;
            statusDiv.style.color = isError ? 'red' : '#666';
            if (isError) console.error(message); else console.info(message);
        }

        function showLoader(show) {
            loader.style.display = show ? 'inline-block' : 'none';
            cameraButton.disabled = show;
            modelSelect.disabled = show;
            // if (ocrModelSelect) ocrModelSelect.disabled = show;
            confThreshInput.disabled = show;
        }

        async function loadAppConfigAndSetup() {
            showLoader(true);
            updateStatus("Cargando configuración de la aplicación...");
            try {
                const response = await fetch('./app-config.json'); // Asume que está en la misma carpeta que index.html o en src/
                if (!response.ok) throw new Error(`Error HTTP cargando app-config.json: ${response.status}`);
                appConfig = await response.json();
                console.log("Configuración de la aplicación cargada:", appConfig);

                // Poblar selector de detector
                detectorModelSelect.innerHTML = ''; // Limpiar opciones previas
                for (const key in appConfig.detectors) {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = appConfig.detectors[key].name;
                    detectorModelSelect.appendChild(option);
                }
                detectorModelSelect.value = appConfig.defaultSettings.detectorKey;

                // Poblar selector de OCR (si existe en el HTML)
                /*
                if (ocrModelSelect && appConfig.ocrModels) {
                    ocrModelSelect.innerHTML = '';
                    for (const key in appConfig.ocrModels) {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = appConfig.ocrModels[key].name;
                        ocrModelSelect.appendChild(option);
                    }
                    ocrModelSelect.value = appConfig.defaultSettings.ocrKey;
                }
                */
                confThreshInput.value = appConfig.defaultSettings.confThresh;
                updateStatus("Configuración cargada. Listo para inicializar modelos.");
                showLoader(false);
                cameraButton.disabled = false; // Habilitar botón después de cargar config

            } catch (error) {
                updateStatus(`Error cargando app-config.json: ${error.message}`, true);
                showLoader(false);
                cameraButton.disabled = true;
            }
        }

        async function initializeOrReinitializeAlprWorker() {
            if (!appConfig) {
                updateStatus("Configuración de la aplicación no cargada. No se puede inicializar el worker.", true);
                return;
            }
            showLoader(true);
            const selectedDetectorKey = detectorModelSelect.value;
            // const selectedOcrKey = ocrModelSelect ? ocrModelSelect.value : appConfig.defaultSettings.ocrKey;
            const selectedOcrKey = appConfig.defaultSettings.ocrKey; // Usar OCR por defecto de config
            const currentConfThresh = parseFloat(confThreshInput.value);

            updateStatus(`Inicializando ALPR Worker con detector: ${appConfig.detectors[selectedDetectorKey].name}...`);

            if (alprWorker) {
                console.log("Terminando worker ALPR anterior...");
                alprWorker.terminate();
                alprWorker = null;
            }
            isWorkerInitialized = false;
            alprWorker = new Worker('./alpr_worker.js', { type: 'module' }); // Ruta desde la raíz del proyecto (donde está index.html)

            alprWorker.onmessage = function (e) {
                const { type, success, error, results, frameId, payload } = e.data; // payload es usado por initComplete

                if (type === 'initComplete') {
                    showLoader(false);
                    if (payload && payload.success) { // Worker usa 'payload.success'
                        isWorkerInitialized = true;
                        updateStatus(`ALPR Worker inicializado (${appConfig.detectors[selectedDetectorKey].name}).`);
                        if (isCameraRunning && !animationFrameId) {
                            lastProcessTime = performance.now();
                            animationFrameId = requestAnimationFrame(videoProcessingLoop);
                        }
                    } else {
                        updateStatus(`Error al inicializar ALPR Worker: ${payload.error || 'Desconocido'}`, true);
                        alprWorker = null;
                    }
                } else if (type === 'frameProcessed') {
                    processingFrameInWorker = false;
                    if (error) {
                        console.error(`Error del Worker (frame ${frameId}):`, error);
                    } else if (results) {
                        drawAlprResults(results, processedCanvas, canvasCtx, videoElement);
                        if (results.length > 0) {
                            let resultsTextContent = `Detecciones: ${results.length}\n\n`;
                            results.forEach((item, index) => {
                                const det = item.detection;
                                const ocr = item.ocr;
                                const detConf = det && typeof det.confidence === 'number' ? (det.confidence * 100).toFixed(1) : "N/A";
                                const ocrText = ocr && ocr.text ? ocr.text : "N/A";
                                const ocrConf = ocr && typeof ocr.confidence === 'number' ? (ocr.confidence * 100).toFixed(1) : "N/A";
                                resultsTextContent += `Placa ${index + 1}: ${ocrText} (OCR:${ocrConf}%) (Det:${detConf}%)\n`;
                            });
                            resultsArea.textContent = resultsTextContent.trim();
                        } else {
                           // No limpiar si no hay resultados, drawAlprResults ya lo hace.
                        }
                    }
                } else if (type === 'initError') {
                    showLoader(false);
                    updateStatus(`Error crítico inicializando Worker: ${error}`, true);
                    alprWorker = null;
                }
            };

            alprWorker.onerror = function(err) {
                console.error("Error en ALPR Worker:", err.message, err);
                updateStatus(`Error fatal en ALPR Worker: ${err.message}`, true);
                showLoader(false);
                isWorkerInitialized = false;
                if (alprWorker) alprWorker.terminate();
                alprWorker = null;
            };

            const workerConfigPayload = {
                appConfig: appConfig,
                selectedDetectorKey: selectedDetectorKey,
                selectedOcrKey: selectedOcrKey,
                confThresh: currentConfThresh
            };
            console.log("Hilo Principal: Enviando mensaje 'INIT' al worker con payload:", workerConfigPayload);
            alprWorker.postMessage({ type: 'INIT', payload: workerConfigPayload });
        }

        function drawAlprResults(alprResults, canvas, ctx, videoSourceElement) {
            if (!videoSourceElement || videoSourceElement.videoWidth === 0 || videoSourceElement.videoHeight === 0) {
                return; // Video no listo
            }

            if (canvas.width !== videoSourceElement.videoWidth || canvas.height !== videoSourceElement.videoHeight) {
                canvas.width = videoSourceElement.videoWidth;
                canvas.height = videoSourceElement.videoHeight;
            }

            const videoRect = videoSourceElement.getBoundingClientRect();
            if (canvas.style.width !== videoRect.width + 'px' || canvas.style.height !== videoRect.height + 'px') {
                canvas.style.width = videoRect.width + 'px';
                canvas.style.height = videoRect.height + 'px';
            }
            canvas.style.position = 'absolute';
            canvas.style.left = videoSourceElement.offsetLeft + 'px';
            canvas.style.top = videoSourceElement.offsetTop + 'px';

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!alprResults || alprResults.length === 0) return;

            const scaleX = canvas.width / videoSourceElement.videoWidth;
            const scaleY = canvas.height / videoSourceElement.videoHeight;

            alprResults.forEach(item => {
                const { detection, ocr } = item;
                if (!detection || !detection.boundingBox) return;
                const bb = detection.boundingBox; // Este es DetectorBoundingBox de plateDetector.js
                const x1 = bb.x1 * scaleX;
                const y1 = bb.y1 * scaleY;
                const width = bb.width * scaleX;   // bb.width ya está calculado en plateDetector.js
                const height = bb.height * scaleY; // bb.height ya está calculado

                ctx.strokeStyle = 'lime';
                ctx.lineWidth = Math.max(1, Math.min(2, canvas.width / 320));
                ctx.strokeRect(x1, y1, width, height);

                const detConf = typeof detection.confidence === 'number' ? (detection.confidence * 100).toFixed(0) : "";
                const ocrTextLabel = ocr && ocr.text ? ocr.text : "";
                const ocrConfLabel = ocr && typeof ocr.confidence === 'number' ? (ocr.confidence * 100).toFixed(0) : "";
                const label = `${ocrTextLabel} (D:${detConf}% O:${ocrConfLabel}%)`;
                const fontHeight = Math.max(10, Math.min(14, Math.round(canvas.width / 40)));
                ctx.font = `bold ${fontHeight}px Arial`;
                ctx.textBaseline = 'bottom';
                const textMetrics = ctx.measureText(label);
                const textWidth = textMetrics.width;
                ctx.fillStyle = 'rgba(0, 255, 0, 0.75)';
                ctx.fillRect(x1, y1 - (fontHeight + 4), textWidth + 4, fontHeight + 4);
                ctx.fillStyle = 'black';
                ctx.fillText(label, x1 + 2, y1 - 2);
            });
        }

        async function startVideoStream() {
            if (isCameraRunning) return;
            if (!isWorkerInitialized) {
                 updateStatus("Worker no inicializado. Por favor, selecciona un modelo y espera.", true);
                 // No intentar iniciar el worker aquí, el usuario debe hacerlo con el botón de selección o el de cámara
                 return;
            }

            updateStatus("Iniciando cámara...");
            showLoader(true);
            try {
                const constraints = { video: { facingMode: "environment" }, audio: false };
                videoStream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = videoStream;
                videoElement.onloadedmetadata = () => {
                    processedCanvas.width = videoElement.videoWidth;
                    processedCanvas.height = videoElement.videoHeight;
                    const videoRect = videoElement.getBoundingClientRect();
                    processedCanvas.style.width = videoRect.width + 'px';
                    processedCanvas.style.height = videoRect.height + 'px';
                    isCameraRunning = true;
                    cameraButton.textContent = 'Detener Cámara';
                    cameraButton.classList.add('stop');
                    showLoader(false);
                    updateStatus("Cámara iniciada. Procesando...");
                    lastProcessTime = performance.now();
                    processingFrameInWorker = false;
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    animationFrameId = requestAnimationFrame(videoProcessingLoop);
                };
            } catch (error) {
                updateStatus(`Error al acceder a la cámara: ${error.message}`, true);
                isCameraRunning = false;
                showLoader(false);
            }
        }

        function stopVideoStream() {
            // ... (sin cambios significativos en stopVideoStream, mantener tu lógica)
             if (!isCameraRunning) return;
            updateStatus("Deteniendo cámara...");
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
            }
            videoElement.srcObject = null;
            isCameraRunning = false;
            cameraButton.textContent = 'Iniciar Cámara';
            cameraButton.classList.remove('stop');
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            canvasCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
            resultsArea.textContent = '';
            updateStatus("Cámara detenida.");
            showLoader(false);
            processingFrameInWorker = false;
        }

        function videoProcessingLoop(currentTime) {
            if (!isCameraRunning) {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                return;
            }
            const deltaTime = currentTime - lastProcessTime;
            const interval = 1000 / TARGET_FPS_PROCESSING;

            if (deltaTime >= interval && !processingFrameInWorker && isWorkerInitialized &&
                videoElement.readyState >= videoElement.HAVE_METADATA && videoElement.videoWidth > 0) {
                lastProcessTime = currentTime - (deltaTime % interval);
                processingFrameInWorker = true;
                frameCounter++;
                const tempCaptureCanvas = document.createElement('canvas');
                tempCaptureCanvas.width = videoElement.videoWidth;
                tempCaptureCanvas.height = videoElement.videoHeight;
                const tempCtx = tempCaptureCanvas.getContext('2d', { willReadFrequently: true });
                tempCtx.drawImage(videoElement, 0, 0, tempCaptureCanvas.width, tempCaptureCanvas.height);
                const imageData = tempCtx.getImageData(0, 0, tempCaptureCanvas.width, tempCaptureCanvas.height);
                alprWorker.postMessage({ type: 'processFrame', payload: imageData, frameId: frameCounter }, [imageData.data.buffer]);
            }
            animationFrameId = requestAnimationFrame(videoProcessingLoop);
        }

        modelSelect.addEventListener('change', async () => {
            if (isCameraRunning) stopVideoStream();
            await initializeOrReinitializeAlprWorker();
        });
        confThreshInput.addEventListener('change', async () => { // Re-inicializar si cambia la confianza
            if (isCameraRunning) stopVideoStream();
            await initializeOrReinitializeAlprWorker();
        });

        cameraButton.addEventListener('click', async () => {
            if (!appConfig) { // Asegurarse que la config está cargada
                await loadAppConfigAndSetup();
                if (!appConfig) return; // Si aún no se carga, no continuar
            }

            if (isCameraRunning) {
                stopVideoStream();
            } else {
                if (!isWorkerInitialized) { // Si el worker no está listo, inicializarlo primero
                    await initializeOrReinitializeAlprWorker();
                }
                // Solo iniciar el stream si el worker está (o se ha) inicializado correctamente
                if(isWorkerInitialized) {
                    startVideoStream();
                } else {
                    updateStatus("Fallo al inicializar el worker. No se puede iniciar la cámara.", true);
                }
            }
        });

        // Inicialización al Cargar la Página
        document.addEventListener('DOMContentLoaded', loadAppConfigAndSetup);

    </script>
</body>
</html>